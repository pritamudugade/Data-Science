# -*- coding: utf-8 -*-
"""Numpy theory

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vDiM7MBnttgWErMND-fZLCN7HFoQvdYR
"""

# Numpy
"""
In Python, Numpy is a package which contains classes, functions, variables, large library of mathematical functions etc to work with scientific calculation.
Numpy can be used to create n dimensional arrays where n is any integer. We can create 1 dimensional array, 2 dimensional array, 3 dimensional array and so on.
Numpy’s array class is called ndarray. It is also known by alias name array. There is another class array in python which is different from numpy’s array class.

background data structure of numpy is array.

numpy only supports numeric values, but we can cast them to boolean also.
"""

"""
numpy stands for numerical python
fundamental python pakage for scientific calculations, to solve mathematical problems
it written in C and Python
open source and has many contributors
we can create array and perform so much function using this
Array, linear algebra
"""

"""numpy has very good memory handling capacity"""
# we can store integer values in int8,32,64 bit same for float nums
import numpy as np
a = np.array([1,2,3], np.int8)                # values are small hence we used int8, and save the memory
print(a)                         # this will affect when we worked with huge data
print(a.dtype)

# methods to create numpy array
"""
1. conversion method- supply python list,  tuple structure into array
2. intrinsic method - np.array method like linspace,logspace,arange,zeros,ones
3. reading array from disk
4. create array through raw byte string, buffer
5. use special library like random

#  create array using array module
import array
a = array.array("i",[10,20,30])
print(a)
print(type(a))

# array vs list
"""
similarity  - store data, mutable, can be indexed and sliced

difference - same data type is required
array is more efficient than list, but it takes only one type of datatype. we can supply hetrogeneous data type in the list.
"""

import numpy as np
a = np.array([10,20,30])      # array using numpy module
print(a)
print(a/3)                    # operation can be performed


import array 
b = array.array("i", [10,20,30])      #array using array module
print(b)
# print(b/3)     # array with array module,we cannot perform operation

c = [10,20,30,40]
print(c)
#print(c/3)             # we cant perform operation with list..


"""to use array we need to import the library but in case of list its a built in module
advantages - consume less space/ memory, fast, most convenient to use"""

# array- most popular concept in C, C++
# array creation
# two ways to create array
import array
a = array.array("i", [1,2,3])
print(a)

import numpy
b = numpy.array([10,20,30])
print(b)

# create array using numpy
import numpy as np
a = np.array([10,20,30])
print(a)
print(type(a))              # type is ndarray. n-dimensional array

# we can supply set in numpy array
a = {1,2,3,4}
import numpy as np
b = np.array(a)
print(b)
print(type(b))     
print(b.dtype) # it returns the object type. ..but in numpy, integer and float is more convinient than obejct to do the arth.operations

# we can create array using list, tuple
a = [10,20,30]
import numpy as np
b = np.array(a)
print(b)
print(type(b))

import array 
c = array.array("i", a)
print(c)
print(type(c))

# numpy array attributes
import numpy as np
a = np.array([10,20,30,40])
print(a)
print(type(a))
print(a.size)
print(a.shape)
print(a.dtype)
print(a.nbytes)
print(a.itemsize)
print(a.ndim)
print(a.item)
print(a.max)
print(a.min)
print(a.sum)

# 1D, 2D and multidimensional array
import numpy as np
a = np.array((1,2,3,4))
print(a)
print()

b = np.array([[10,20],[30,40]])
print(b)
print(b.size)       # 4 elemnts
print(b.shape)       # 2X2
print(b.ndim)        # 2D

# various changes in array
# change datatype
a = np.array([[10,20],[30,40]])
print(a, type(a))

a = np.array([1,2,3], dtype = float)
print(a)
print(type(a))              # type returns type of datastructure
print(a.dtype)                # dtype return the type of data

# various functions of numpy array
# 1. arange()            # same as range function
# syntax- a.arange(start,stop,step, dtype= None)              # stop is exclusive
import numpy as np
a = np.arange(1,10,1, dtype=float)
print(a)                            # 10 is exclusive

a = np.arange(1,10,2)
print(a)

a = np.arange(1,50,6)
print(a)

a = np.arange(20,2,-1, dtype=float)       #positive reverse with step 1
print(a)

a = np.arange(-1,-15, -2)            #negative range with step 2
print(a)

a = np.arange(-15,-2)                 # negative reverse    
print(a)

# we can use float values too                       # this is not possible with python range(), float range
a = np.arange(1.6, 5.9, 1)
print(a)

# step size can be float
a = np.arange(1.6,10.2,2.6)
print(a)

a = np.arange(-10,0)     # negative dtype=int bydefault
print(a)

from numpy import *          # * is use to call all sub modules
a = arange(10)                 # starts with 0 bydefault, ends n-1, step size = 1,
print(a)

# linspace()-

# numpy.linspace (start, stop, num=50, endpoint=True, retstep=False, dtype=None, axis=0)
# start point - inclusive
# num = equal divided parts, by default 50
# endspoint = True means endpoint inclusive otherwise exclusive, if true stop is last element, if false stop not included
# retstep = distance between two intervals
# dtype bydefault float

import numpy as np
a = np.linspace(1,5)                # divides 1,5 into 50 intervals, 
print(a)               # endpoint is true by deafault hence 5 also printed

print()
a = np.linspace(10,50,20)          # intervals are 20, equally spaced
print(a)

# linspace with int dtype
a = np.linspace(20,40,30, dtype = int)
print(a)                                # round off all values

a = np.linspace(3,40,30, dtype = int)
print(a)

#linspace with retstep
# when retstep = true, it returns the space distance between two intervals
a = np.linspace(1,10,5, dtype=float, retstep=True)
print(a)                 # 2.25 is distance between two intervals

"""
logspace - function used to create the array with equal spacing logarithmically 
The sequence starts at base ** start (base to the power of start) and ends with base ** stop.

Syntax:- 
numpy.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None, axis=0)

Where,
start – It represents starting element which will become base to the power of start 〖(𝑏𝑎𝑠𝑒〗^𝑠𝑡𝑎𝑟𝑡)
stop – It represents ending element which will become base to the power of stop (〖𝑏𝑎𝑠𝑒〗^𝑠𝑡𝑜𝑝)
num – It represents number of parts the element should be divided. Default is 50. It must be non-negative.
endpoint- If True, stop is the last element. If False, stop is not included.
base - The base of the log space.
dtype – The type of output array.
"""

import numpy as np                     # same as linspace
a = np.logspace(1,50,20)
print(a)

# zeros()
"""
zeros() - Function is used to create an array with all zeros.
Syntax:- 
numpy.zeros(shape, dtype=float, order='C')
Where,
shape – shape of new array. It can be an int which will represent number of elements or can be tuple of int. ex:- 5, (5, ) (3, 1)
dtype – The desired data-type for the array.
Order  - Whether to store multi-dimensional data in row-major (C-style) or column-major (Fortran-style) order in memory. 
It can be C or F.
"""

import numpy as np
a = np.zeros((2,2))          # two rows two columns
print(a)
print()
a = np.zeros((2,3))          # 2 rows 3 columns
print(a)
print()
a = np.zeros((2,3), dtype=int)                     # by changing data type to int, by default is float
print(a)

print()
a = np.zeros(5)                      # 5 rows, 1 dimensional
print(a)

a = np.zeros((5,4,3), order="C")                        # order by default "C"  c-style, column major
#print(a)
a = np.zeros((5,4,3), order="F")                        # order is F       f-style, fortran style
#print(a)

# ones- to fill the matrix with ones
"""
ones ( ) Function is used to create an array with all 1s.
Syntax:- 
numpy.ones(shape, dtype=float, order='C')
Where,
shape – shape of new array. It can be an int which will represent number of elements or can be tuple of int.
dtype – The desired data-type for the array. Default is float.
Order  - Whether to store multi-dimensional data in row-major (C-style) or column-major (Fortran-style) order in memory. It can be C or F."""

import numpy as np
a = np.ones(5)
print(a)

import numpy as np
a = np.ones(5, dtype=int)
print(a)

a = np.ones((3,2), order="F")
print(a)

# same as zeros, only gives the ones

# empty() - empty returns the arbitary nums
# same as zeros and ones, but bit faster than zeros,ones.
# empty returns the arbitary nums, garbage values. it holding the container of values for future. occupied the memory

# syntax - empty(shape, dtype=float, order = "C")

import numpy as np
a = np.empty((3,3))
print(a)

print()

b = np.empty((2,1))
print(b)

# asarray- it converts the list/tuple into array

# syntax - np.asarray(tuple/list, dtype=None, order=None,*,like=None)

a = [10,20,30,40,50]
import numpy as np
b = np.asarray(a)
print(b)
print(type(b))
print(b.dtype)

# can we convert array into array with asarray
# ans- no, because it will only works when there is something to convert. 
# we can change the datatype. 

c = np.asarray(b)
print(c)
print(c.dtype)                  # nothing is change

c = np.asarray(b, dtype= float)
print(c)
print(c.dtype)

# eye() - to create identity matrix, it makes the diagonal 1, and other zero
# The eye method can be used to create an identity matrix, which can be very useful to perform a variety of operations in linear algebra. 
# An identity matrix is a matrix with zeros across rows and columns except the diagonal.
# The diagonal values are all ones.
# syntax - np.eye(int,M=None,k=0,dtype=float,order="c",*,like=None) 
# M is column, by default same as rows, k is position of diagonal
import numpy as np
a = np.eye(5)
print(a)
print()

b = np.eye(5,4)
print(b)
print()

c = np.eye(6, k=1)           # when k is 1, then above the diagonal
print(c)

print()
d = np.eye(4, k=-1)
print(d)

# identity() - square array with one in diagonal,
# systax - np.identity(n, dtype=None, * , like=None)
import numpy as np
a = np.identity(4)
print(a)
"""
b = np.indetity(3, 4)
print(b)        # reshaping not possible, it throws the error, only we can create the square matrix
"""
print()
c = np.identity(3, dtype = float)
print(c)

# astype() - The astype() function creates a copy of the array, and allows you to specify the data type as a parameter
import numpy as np
c = [1,2,3,4,5]
a = np.array(c)
print(a)
print(a.dtype)

# if i want to change the dtype of given array a
b = a.astype(float)
print(b)
print(b.dtype)

# What is the difference between .dtypes and Astype () function?
# If the function accepts the dtype parameter then use it. If it doesn't accept that parameter you'll have to use the astype .

# ones_like()- returns the array like ones, function returns an array of given shape and type as a given array, with ones.
# Syntax: numpy.ones_like(array, dtype = None, order = 'K', subok = True)
a = np.arange(16).reshape(4,4)
print(a)

print()
b = np.ones_like(a, dtype=float)
print(b)
# it returns the same shape with 1 fill in array

# zeros_like - function returns an array of given shape and type as a given array, with zeros., same as ones_like
a = np.arange(12).reshape(4,3)
print(a)

print()
b = np.zeros_like(a, dtype=float)
print(b)
# it returns the same shape with 0 fill in array

# empty_like() - return same function like empty, fill values with arbitary values
import numpy as np
a = np.array([[2,5,6],[3,8,7]])
print(a)

# empty_like()

b = np.empty_like(a)                  # a is having (2,3) shape, so empty like will take a same shape and return arbitary values 
print(b)

# full_like() - return a new array with the same shape and type as a given array.
# to fill the value with specific number
#Syntax : numpy.full_like(a, fill_value, dtype = None, order = 'K', subok = True)

import numpy as np
a = np.arange(9).reshape(3,3)
print(a)
print()
b = np.full_like(a, 7, int)
print(b)

# reshape() - to reshape the array

# syntax = np.reshape(array, (p,q,r))                # p = layers, q = rows, r = columns
a = np.arange(24)
print(a)
print(a.shape)
print(a.size)
print(a.ndim)
print()
# if i want to make it 6X4, 2D
b = a.reshape(6,4)
print(b)
print(b.shape)
print(b.size)
print(b.ndim)
print()
# 3D - (2,3,4)
c = a.reshape(2,3,4)
print(c)
print(c.shape)
print(c.size)
print(c.ndim)

# non-zero - returns the indices of non zero values
# syntax = np.nonzero(array)
a = np.array([1,2,3,4,0,7,8,9,0,5])
print(a)

b = np.nonzero(a)
print(b)               # answer is indices of nonzero values.

c = np.array([[0, 8, 0], [7, 0, 0], [-5, 0, 1]])
print(c)
d = np.nonzero(c)
print(d)
print()
e = np.array([[1,2,0],[0,4,5],[0,0,1]])
print(e)
print(np.nonzero(e))
print()
f = e[np.nonzero(e)]                  # to get the non zero elements 
print(f)

# concept of axis
# axis = 0, row, vertical vals comes in picture
# axis = 1, colums, horizontal vals comes in picture

# transpose - to change the axis.
# syntax- np.transpose(array, axes=None)
import numpy as np
a = np.array([[1,2,0],[0,4,5],[0,0,1]])
print(a)
print(a.shape)
print()
print(a.T) #column become rows and vice versa
print()
a = np.array([[10,20],[30,40]])
print(a)
print(a.T)


print(a.transpose())

# transpose rearrange (reverse) the shape of given array 
a = np.arange(24).reshape(2,3,4)
print(a)
print()
b = np.transpose(a)
print(b)
print(b.shape)                 # original shape was (2,3,4), new shape is (4,3,2)


# it will give same result on 1D array, no change
a = np.arange(10)
print(a)
print(np.transpose(a))           # no change in op


# transpose with axis
# bydefault its none
print("transpose with axis")
a = np.arange(12).reshape(3,4)
print(a)

print(np.transpose(a, axes=(1,0)))         # reverse chnage happen,


print(np.transpose(a, axes=(0,1)))            # no change

# for 3d array
a = np.arange(24).reshape(2,3,4)
print(a)

print()

b = np.transpose(a, axes=(0,1,2))                # it wont change happen, transpose
print(b)
print(b.shape)

b = np.transpose(a, axes=(1,2,0))                #  change happen, transpose
print(b)
print(b.shape)

# transpose with axis
# for 2D array
a = np.array([[1,2,3],[4,5,6]])
print(a)

print()
# for 2d array- axis(0,1)     by default - 0  for rows, 1 for columns

# for 3d array
a = np.arange(27).reshape(3,3,3)
print(a)
# for 3d array - axis(0,1,2)        by default,  0 for layer, 1 for rows, 2 for column

# Transpose function as a method
a = np.array([[10,20],[30,40]])
print(a)

print(a.transpose())

print(a.T)

# swapaxes-function interchange two axes of an array. 
#Syntax : numpy.swapaxes(arr, axis1, axis2) 

a = np.array([[10,20],[30,40]])
print(a)
print(np.swapaxes(a, 0,1))
print()
a = np.array([[1,2,3]])
print(a)
print(np.swapaxes(a, 0, 1))
print(np.swapaxes(a, 1, 0))              # will get same op

print()
a = np.arange(1,25).reshape(2,3,4)
print(a)
print(np.swapaxes(a,1,2))

# we can use swapaxes as a method also
a = np.arange(1,25).reshape(2,3,4)
print(a)
print(a.swapaxes(1,2))
print(a.shape)

# difference between transpose and swapaxes
# both are used to rearrange the dimension of array. 
# in transpose we can rearrange all the dimensions or we can rearrange only 2, but in swapaxes we can interchange only 2 dimensions not all.

# random()- To create a random nums
# rand - for uniformly distribution of nums
# randin - for normally distribution of nums, gaussian distrubution
# randint - for random integers.. uniformly distributed
# ranf - for flot numbers - uniformly distributed

# rand - uniformly distribution of nums betweeen 0 and 1
# syntax - np.random.rand(shape)
import numpy as np
a = np.random.rand(2,3)                   # 2 rows, 3 column
print(a)

# randn method- to create normally distribution of nums, gaussian distrubution
import numpy as np
a = np.random.randn(2,3)                   # 2 rows, 3 column
print(a)

# randint method - to get the random integers
# syntax - np.random.randint(low,high,size=None,dtype=int)
import numpy as np
a = np.random.randint(50,100,5)             # to get the 5 random int between 50 to 100,
print(a)

a = np.random.randint(10,20)            # when we only supply range then it will return only one randint
print(a)

a = np.random.randint(10)            # when we only supply one input it will return only one randint and take 0 as start point 
print(a)

# ranf - to get the random float point values
import numpy as np
a = np.random.ranf(20)
print(a)

# random sample - we can supply list/tuple/set/dict as input
import numpy as np
from random import sample
list = [1,2,3,4]
a = (sample(list, 2))
print(a)

# ravel()- to convert 2D or 3D array into 1D array
a = np.arange(1,25).reshape(2,3,4)
print(a)

# syntax - np.ravel(a, order)                # order = "C" bydefault
b = np.ravel(a, order="C")
print(b)                         # converted into 1D

# it returns the view of original array, it doesnt create array copy, hence consume less space. ravel can apply on any object, 
# faster, changes in ravel , will affect the oiriginal array.

# flatten() - numpy method, to flatten the mulitidimensional (2d,3d) array into 1D array.  it creates the copy of array and store separatly.
#hence takes more space/memory and lil bit slow
# syantax - a.flatten(order)
a = np.arange(1,25).reshape(2,3,4)
print(a)
print()
b = a.flatten(order = "C")
print(b)

# difference between ravel and flatten
# both are used for convert multidimensional array into 1D
# ravel is built in library of numpy, whereas flatten is method of numpy
# ravel doesnt create copy, it gives the view of original array, hence requires less space and faster, but due to view, any changes made in array will affect the original array
# whereas flatten creates the copy of original array so consume more space,and slower but as it create copy, chnges will not affect the original array.

# ravel can takes any input like list,tuple
tuple1 = (1,2,3,4)
a = np.ravel(tuple1)
print(a)

# flatten doesnt work with list/tuple other than ndarray
#tuple1 = (1,2,3,4)
#a = tuple1(flatten)
#print(a)
#gives the error

# difference between copy and view
# when we copy array, python allots the separate memory for copied array.
# hence any changes into  copied array will not affect the original array

a = np.array([10,20,30,40])
print(a)
b = np.array(a)
print(b)

b[2]= 50
print(b)             # changes in copied array will not affect original
print(a)          

# view- it just gives the view of array, doesnt create any separate memory, chnages made in view array, will affect the original array
a = c
print(c)

c[2] = 100
print(c)
print(a)      # affect the original array

# when we create view, it means we create a aliasing of array
a = c

# array manipulation
# reshape
import numpy as np
a = np.arange(24).reshape(3,2,4)             # 3 layer, 2 rows, 4columns
print(a)
print()
# we can rehape into 2d
b = np.reshape(a, (2,4,3))
print(b)

# resize() - we can resize the array
c = np.resize(a, (4,4,4))                 # greater than original
print(c)

# here original size of array was 24, and shape (3,2,4), we have given the size(4,4,4) means 64 in input, means = 64-24 = 30
# numpy will add extra zeros and extra repeated arrays in new array


d = np.resize(a, (3,3))                 # less than original
print(d)
# when we supplied less size than original then it will eliminated extra numbers and make a first num of given size, shape array

# transpose- rearrange the shape, more specific..reverse the given shape
# suppose, given shape is (2,3,4) then transpose shape will be (4,3,2)
# if (4,3) then (3,4)
a = np.arange(12).reshape(4,3)
print(a)
print()
b = a.T
print(b)

# swapcase - swapping axis
# generally, axis1 = rows, axis2 = column

import numpy as np
# concatenate- to concatenate the arrays with same shape
# syntax- concatenate((array1,array2), axis=0,)

a = np.array([10,20,30])
b = np.array([50,60,70])
c = np.concatenate((a,b), axis=None)
print(c)

x = [10,20,30]
y = [40,50,60]
print(x+y)    # wwe use + sign to concatenate list
# but in array, it adds two arrays

print(a+b)              # add array
 
new = np.concatenate((a,b))             # concatenate the array
print(new)

##
# when axis = None it first flatten the array, and then concatenate

c = np.array([[1,2],[3,4]])
d = np.array([5,6])

print(c)
print(d)
"""
e = np.concatenate((c,d))
print(e)
""" # throw error as dimensions are different

e = np.concatenate((c,d.T), axis=1)
print(e)

# split()
import numpy as np
a = np.arange(16).reshape(4,4)
print(a)

b = np.split(a, 2)                 # split in 2
print(b)

b = np.split(a,4)                  # split in 4
print(b)

# comparison of np.arrays
import numpy as np

a = np.array([1,2,3,4,5])
b = np.array([4,5,6,7,8])

c = a > b
print(c)

d = a < b
print(c)

e = a == b
print(e)

# indexing -- 
# access elememts by indexing method

# 1 dimensional
a = np.array([10,20,30,40,50,60])
print(a)

print(a[2])          # access 30

print(a[-1])           # last element.. negative indexing can be possible

print(a[-4])          # 30

print(a[(-2)])            # 50

# 2D indexing by using  (a[(row,column)])

print(" indexing by using---(a[(row,column)])")
a = np.arange(9).reshape(3,3)
print(a)
print(a.ndim)
print()
print("positive indexing")
print(a[(1,2)])                # to access 5, (row,column) list of tuple
print(a[2,0])
print()

print("negative indexing")
# negative indexing
print(a[(-1,-1)])            # 8
print(a[(-1,-3)])            # 6
print(a[(-3,-1)])            # 2
print()

print("positive indexing")
b = np.array([[10,20,30],[40,50,60]])
print(b)

print(b[(0,1)])               # to access 20
print(b[(1,2)])                # to access 60

print("negative indexing\n")
print(b[-1][-3])              # 40
print(b[-2][-1])            # 30

# 2D indexing with a[row][column]

print(" indexing by using---(a[row][column])")
a = np.arange(9).reshape(3,3)
print(a)
print(a.ndim)             # 2 Dimensional
print()
print("negative indexing")
print(a[1][2])               # 5
print(a[0][0])                     # 0
print(a[2][0])                   # 6
print()
print("negative indexing")
# negative indexing
print(a[-1][-2])          # 7
print(a[-2][-3])              # 3
print(a[-2][-1])                # 5
print()
b = np.array([[10,20,30],[40,50,60]])
print(b)

print(b[0][2])                    # to access 30
print(b[0][1])                      # to access 20
print(b[1][2])                     # 60
print(b[1][-1])                      # 60 
print()
print("negative indexing")
# negative indexing
print(b[-1][-1])            # 60
print(b[-1][-3])          # 40
print(b[-2][-1])      # 30

# 3D indexing
print("3D indexing")
import numpy as np
a = np.arange(48).reshape(3,4,4)
print(a)
print()
print("indexing using---a[(layer,row,column)]")

print(a[(0,2,3)])         # 11         layer-0, row-2, column-3
print(a[(0,3,0)])         # 12
print(a[(0,1,1)])         # 5
print(a[(1,3,0)])         # 28
print(a[(1,1,2)])         # 22
print(a[(1,3,3)])         # 31
print(a[(2,2,3)])         # 43
print(a[(2,1,1)])         # 37
print(a[(2,0,3)])         # 35
print()
print("indexing using---a[layer][row][layer]")

print(a[0][2][0])          # 8
print(a[1][3][0])          # 28
print(a[1][0][3])          # 19

print()
print("negavtive indexing")
print("negative indexing using a[(layer,rows,column)]")
print(a[(-3,-2,-3)])        # 9
print(a[(-1,-2,-2)])        # 42
print(a[(-2,-4,-1)])        # 19

print()
print("negavtive indexing")
print("negative indexing using a[layer][row][column]")
print(a[-2][-2][-4])                # 24
print(a[-1][-3][-4])               # 36
print(a[-3][-3][-1])                     # 7

# slicing - to retrive collection of data, to slice off data and take out part
# syntax - array_name(start,stop,step)                # stop exlusive

# 1d array
import numpy as np
a = np.arange(6)
print(a)

# slicing
print(a[2:4:1])
print(a[::-1])                  # reverse array

# negative slicing not possible 

print(a[::2])        # step 2, even values
print(a[1::2])           # odd values

# slicing of 2D array
import numpy as np
a = np.arange(1, 13).reshape(3,4)
print(a)

# slicing
# syntax- array_name[ : : , : : ]

print(a[1:,1:])            # 

print(a[:-1,:-1])          # reverse array

print("2d slicing-- using a[::,::]")     # a[row,column],   a[rowstart:rowstop:step, columstart:columnstop:step]

import numpy as np
a = np.arange(1,17).reshape(4,4)
print(a)

print(a[1:3,1:3])

print(a[2:,0:2])

print(a[0:1,2:])

print(a[2:3,2:])

print(a[1:2,0:2])

print(a[2:,1:2])

print(a[0:2,3:])

print(a[1: ,2:3])

print(a[1: ,1:])

print(a[0:, 0:])          # whole array

print(a[1: :2,1: :2])          # step size two

print("3d slicing-- using a[::,::,::]")     # a[layer, row,column],   a[layerstart:layerstop:step, rowstart:rowstop:step, columstart:columnstop:step]
import numpy as np
a = np.arange(1,19).reshape(2,3,3)
print(a)

print(a[0:1, 1:,1:])

print(a[0:1, :2, 1:])

print(a[1:, 2:,0:])

print(a[1:,1:2,1:])

# negative slicing 2d array
import numpy as np
a = np.arange(1,10).reshape(3,3)
print(a)

print(a[-2:,-3:-1])

print(a[-1:-3, -1:-2])

# there are two types of indexing- 1. basic indexing 2. advance indexing

# basic indexing- we have done 

# advance indexing having two types = 1. integer indexing and 2. boolean indexing

# integer indexing returns the integer values...

# normal indexing returns the view type data..any operation not possible

# advance indexing - we can access elements which are unordered, and also repeated. 
# we can access number randomly and print it repeatdly

# it returns the copy of data, changes will not affect original array

a = np.array([10,20,30,40,50,60])
print(a)

# syntax of advance indexing--- arr[index]             # index can be ndarray or list

# want to access, 30 (3 times)
print(a[[2,2,2]])                 # should be in list of list         # here we have provided list as index[2,2,2]


# when we provide [] single sq bracket, then it will considered as basic indexing, and will generate error, out of index

print(a[[2,3]])                    # [2,3] index provided


# we can perform any arthmetic operation with advance indexing
print(a[2]+3)   # 30 + 3 = 33

print(a[[2,0,4]])           # 2-30, 0-10, 4-50

print(a[4]**2)    # SQ of 50

# advance indexing with 2D-- Fancy indexing

# advance indexing requires 2 sq bracket, indices in list of list

# syntax - a[[row indices],[columns indices]]                # should be enclosed in list of list
 
# this indexing is known as fancy indexing- we can take out more than 2 elemnts from array. 

a = np.arange(9).reshape(3,3)
print(a)

print(a[[2,1],[2,0]])           # access 8, 3 

print(a[[0,2],[2,0]])            # access 2, 6

print(a[[2,1],[1,0]])              # access 7 , 3

# more than one can be possible

print(a[[1,0,2],[2,0,0]])          # access 5,0,6.

print()
print("nagative indexing with advacnce")

print(a[[-2,-3],[-3,-1]])             # access 3,2

print(a[[-1,-2],[-1,-2]])            # 8,4

a = [10,20,30,40,50,60,70]
print(a[1:5])          # there should be 4 elements, 5-1=4
# [20, 30, 40, 50]

# boolean indexing - True or False
# syntax - a[expression]               # it works like if statement, if expression true then only print values

a = np.array([1,2,3,-5,7,-1,-6,7,-14])
print(a)
print(a[a<0])            # want to print negative values

print(a[a>0])         # positive values

print(a[a%2==0])          # even values

print(a[a%2!=0])         # odd values


print(a[a%2==0]*2)           # even nums , multiply by 2

# 2d array
a = np.arange(1,13).reshape(4,3)
print(a)

print(a[a%2==0])

print(a[a>6])
print()
print(a>4)

# printing rows and colums
a = np.arange(1,17).reshape(4,4)
print(a)

print(a[0])          # 1st row

print(a[:,2])             # 2nd column

# max and min
a = np.arange(1,17).reshape(4,4)
print(a)

print(np.max(a))

print(np.min(a))

# sum()
a = np.arange(1,17).reshape(4,4)
print(a)
print(np.sum(a))

# sum function
print(a.sum(axis=0))     # vertical sum

print(a.sum(axis=1))      # horizontal sum

# nonzero = it returns the index of non zero values
import numpy as np
a = [0,1,2,6,4,78,0,2,5,0,6]
print(a)

b = np.nonzero(a)           # it returns the index of nonzero vals
print(b)

c = np.count_nonzero(a)      # it returns total count 8
print(c)

# finding elements
# where()
import numpy as np
a = np.arange(16).reshape(4,4)
print(a)
b = np.where(a>=5)
print(b)

# exp() ---exponant
a = np.arange(1,17).reshape(4,4)
print(a)

print(np.exp(a))


# sqrt --- sqroot
print(np.sqrt(a))

# flat
import numpy as np
a = np.random.rand(9).reshape(3,3)
print(a)

print(a.flat)          # it gives the object

for i in a.flat:
  print(i)
print(type(i))
print(i.dtype)

# argmin, argmax                 # return index numbers
import numpy as np
a = np.arange(1,10).reshape(3,3)
print(a)

print(a.argmin())               # it returns the index number    
print(a.argmax())                  # max index

print(a.argmin(axis=0))              # 1 2 3
print(a.argmax(axis=0))               # 3 6 9

print(a.argmax(axis=1))

# sort
# argsort
import numpy as np
a = np.array([1,2,4,8,3,7,6,9,0])
print(a)

print(a.argsort())

print(a.argsort(axis=0))

# string operation using numpy
import numpy as np
a = np.array(["hello world"])
print(a)
b = np.array([" hello python"])
print(b)
# addition/concatenation
print(np.char.add(a,b))

# repetion
print(np.char.multiply(a,3))

# front word capital
print(np.char.capitalize(a))

# check size of numpy and compare with list
a = [10,20,30,40,50]
import numpy as np
b = np.array([10,20,30,40,50])
print("list-", a)
print("ndarray-", b)

import sys
li = (sys.getsizeof(a)*len(a))
print("size of list:",li)                            # same data stored in list takes about 480 bytes

arr = b.itemsize*b.size              # itemsize * size of array
print("size of np-array:", arr)                           # array takes only 40 bytes..

# thats why nparray has efficient storage, it consume less memory space hence faster than list

a = [10,20,30,40,50]                         # initialization of list
b = np.array([10,20,30,40,50], np.int8)     # we can set the datatype during ndarray initialization
                                                # here int8, it will help in memory management. 
arr = b.itemsize*b.size              
print("size of np-array:", arr)                             # it takes only 5 bytes memory, hence numpy array has better
                                      # data handling capacity

# who is fast?
# ndarray or list
import numpy as np
import time
a = [10,20,30,40,50]

start1 = time.time()
for i in a:
  print(i, end=" ")
print()
print("time to execute list:", start1-time.time())

b = np.array([10,20,30,40,50])
start2 = time.time()
for j in b:
  print(j, end=" ")
print()
print("time to execute ndarray:",start2-time.time())

# list takes more time than ndarray

-0.002282381057739258 > -0.0029053688049316406

# ndarray to list
import numpy as np
a = np.arange(10)
print(a)
print(type(a))

print(a.tolist())
print(type(a))

# asarray() - # convert list into ndarray
a = [10,20,30,40]
import numpy as np
b = np.array(a)
print(b)

# axis = 0 ------- vertical
# axis = 1 -------- horizontal

# amax() - return maximum array
import numpy as np
a = np.arange(1,10).reshape(3,3)
print(a)
b = np.amax(a)  
print(b)